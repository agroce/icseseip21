\section{Introduction}

Bitcoin~\cite{nakamoto2008bitcoin} is the most popular cryptocurrency, and, while volatile, has a market cap consistently over half a trillion dollars since January of 2021.   Bitcoin Core (\url{https://github.com/Bitcoin/Bitcoin}) is by far the most popular implementation, and serves as a reference for all other implementations of Bitcoin.  To a significant degree, the code of Bitcoin Core \emph{is} Bitcoin.  Because of its fame and the high value of Bitcoins, Bitcoin is a high-value target for hackers.  Therefore, testing the code is of paramount importance, including extensive functional tests and aggressive \emph{fuzzing}.  This paper describes a focused effort to identify weaknesses in, and improve, the fuzzing of Bitcoin Core.

%\section{Initial Contact and the Problem of Saturation}

Chaincode Labs (\url{https://chaincode.com/}) is a private R\&D center that exists solely to support and develop Bitcoin.  In March of 2021 the head of special projects at Chaincode contacted the first author to discuss determining a strategy to improve the fuzzing of Bitcoin Core.  It seemed that the fuzzing was ``stuck'': neither code coverage nor found bugs were increasing with additional fuzzing.  After some discussion, an 80 hour effort was determined as a reasonable scope for an external, research-oriented, look at the fuzzing effort.

%Before that effort, conducted over the summer of 2021, began, the problem of saturation resolved itself.  Nonetheless, the issue that drove the initial %desire for a researcher investigation is well worth examining.  Moreover, understanding why Bitcoin Core fuzzing was, temporarily but not %fundamentally, saturated, may be useful to help other fuzzing campaigns avoid the same false saturation problem.

Saturation, as defined in the blog post (\url{https://blog.regehr.org/archives/1796}) that brought Chaincode Labs to the first author, is when ``We apply a fuzzer to some non-trivial system... [and] the number of new bugs found by the fuzzer drops off, eventually approaching zero.''  At first a particular fuzzer applied to a system will tend to continuously increase both coverage and discovery of previously-unknown bugs.  But, at some point, these bugs are known (and often fixed) and the fuzzer stops producing new bugs.  Code and behavioral coverage seems to be \emph{saturated}.
The underlying reason for saturation is that any fuzzer (or other test generator) explores a space of generated tests according to some complex probability distribution.  Some bugs lie in the high-probability portion of this space, and other bugs lie in very low probability zero probability parts.  Escaping saturation may require a variety of approaches.

\section{Results}

One thing that quickly emerged from discussions before the primary 80 hour effort began was the limited extent of the fuzzer runs being performed.  The fuzzing includes a large number of targets, each with its own fuzz harness and executable.  At the time, the basic strategy was to run libFuzzer on each of these for 100,000 iterations.  Because some targets are very fast and a few, such as full message processing, are slow, this meant in practice fuzzing most targets for only 30-90 seconds, and even the slowest targets for only a little over an hour.  The total time for over 100 targets was not negligible, but expecting such short runs for each target, after an initial exploration of the easy part of the probability space, to gain coverage or bugs very often, was simply unrealistic.  In particular, for complex, critical targets such as transaction verification and end-to-end message processing, 100,000 iterations was completely insufficient.  

The first suggestion for escaping coverage, therefore was very simple:  run the fuzzer longer!  The Chaincode team immediately tried increasing their configuration to 5 million iterations, multiplying the number of executions, and runtime, by a factor of 50.  Based on initial success with a few targets, this was done for all targets, and eventually became the new default.  By May 20th, Bitcoin Core was also in OSS-Fuzz: \url{https://github.com/google/oss-fuzz/tree/master/projects/bitcoin-core}.  From then on, Bitcoin Core has essentially been continuously fuzzed, and OSS-Fuzz quickly produced new crashes to investigate, and continues to do so:  \url{https://bugs.chromium.org/p/oss-fuzz/issues/list?q=bitcoin}.

Additonal efforts to improve the fuzzing focused on adding support for the Eclipser fuzzer~\cite{Eclipser}, and attempting to use swarm testing~\cite{ISSTA12} to produce more unusual message sequence interactions.  Using Eclipser produced a large number of additional corpus seeds for OSS-Fuzz (over 2,000 inputs, the third largest contribution to the set to date), while swarm turned out to be ineffective, due to extensive manual cross-seeding providing similar benefits.  Neither approach, however, turned up any new bugs.  It was clear the code coverage from fuzzing was extremely high for most critical components of the code, and improvements were in some sense marginal (new paths or data values only).

\section{Mutation Analysis and Oracle Strength}



\section{Full Report}

The full report on the Bitcoin Core fuzzing investigation can be read here: \url{https://agroce.github.io/bitcoin_report.pdf}.
