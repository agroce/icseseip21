\section{Initial Contact and the Problem of Saturation}

Chaincode labs (\url{https://chaincode.com/}) is a private R\&D center based in Manhattan that exists solely to support and develop Bitcoin.  In March of 2021, Adam Jonas, the head of special projects at Chaincode, contacted the first author to discuss determining a strategy to improve the fuzzing of Bitcoin Core.  In particular, at the time, it seemed that the fuzzing was ``stuck'': neither code coverage nor found bugs were increasing with additional fuzzing time.  After some discussion, an 80 hour effort was determined as a reasonable scope for an external, research-oriented, look at the fuzzing effort.  Before that effort, conducted over the summer of 2021, began, the problem of saturation resolved itself.  Nonetheless, the issue that drove the initial desire for a researcher investigation is well worth examining.  Moreover, understanding why Bitcoin Core fuzzing was, temporarily but not fundamentally, saturated, may be useful to help other fuzzing campaigns avoid the same false saturation problem.

Saturation, as defined in the blog post (\url{https://blog.regehr.org/archives/1796}) that brought Chaincode labs to the first author, is when ``We apply a fuzzer to some non-trivial system... initially it finds a lot of bugs... [but] the number of new bugs found by the fuzzer drops off, eventually approaching zero.''  That is, at first a fuzzer applied to a system will tend to continuously, sometimes impressively, increase both coverage and discovery of previously-unknown bugs.  But, at some point, these bugs are known (and often fixed) and the fuzzer stops producing new bugs.  Code and behavioral coverage seems to be \emph{saturated}.

The underlying reason for saturation is that any fuzzer (or other test generator) explores a space of generated tests according to some, perhaps very complex, probability distribution.  Some bugs lie in the high-probabiliity portion of this space, and other bugs like in very low probability (or in some cases, zero probability) parts of the space.  Unsurprisingly, eventually the high probability space is well-explored, and the remaining bugs are found only very infrequently, if ever.  The underlying empirical facts are cruel, as noted by B\"{o}hme and Falk:  ``[W]ith twice the machines, we can find \emph{all known} bugs in half the time. Yet, finding linearly \emph{more} bugs in the same time requires exponentially more machines'' \cite{fuzzexp}.

Chaincode labs saw that code coverage and bugs were not increasing in their fuzzer runs, and wanted to break out of the saturation trap.  The blog post suggested several methods for doing just that, and this paper explores some of them.  Note that even though the fuzzing was not saturated, the methods for escaping saturation are also useful things to try in any fuzzing effort where finding as many bugs as possible is actually important.

\subsection{We Hold the World Ransom For... ONE MILLION FUZZER ITERATIONS}

One problem for inexperienced fuzzer users is that it is not always clear just how long a fuzzer run is needed.  Anyone used to popular random testing tools, such as QuickCheck~\cite{ClaessenH00}, may expect a ``reasonable'' budget to be on the order of hundreds of tests or at most a few minutes~\cite{HolmesLOC}.  The fuzz testing research community has settled, to some extent, on 24 hours as a basis for evaluation of fuzzers~\cite{evalfuzz}, but even this may be considered a low-budget run in a serious campaign!  The Solidity compiler fuzzing effort discussed in the saturation blog post (\url{https://blog.trailofbits.com/2020/06/05/breaking-the-solidity-compiler-with-a-fuzzer/}, \url{https://blog.trailofbits.com/2021/03/23/a-year-in-the-life-of-a-compiler-fuzzing-campaign/}) found many bugs only after running a specialized version of AFL for over \emph{a month}.

One thing that quickly emerged from discussions with Chaincode before the primary 80 hour effort was the limited extent of the fuzzer runs performed in early April.  The fuzzing includes a large number of targets, each with its own fuzz harness and executable.  At the time, the basic strategy was to run libFuzzer on each of these for 100,000 iterations.  Because some targets are very fast and a few, such as full message processing, are slow, this meant in practice fuzzing most targets for only 30-90 seconds, and even the slowest targets for only a little over an hour.  The total time for over 100 targets was not negligible, but expecting such short runs for each target, after an initial exploration of the easy part of the probability space, to gain coverage or bugs very often, was simply unrealistic.  In particular, for complex, critical targets such as transaction verification and end-to-end message processing, 100,000 iterations was as inadequate a Dr. Evil's famous ransom demand for ``one million dollars'' in the first Austen Powers movie.  Neither the Chaincode team nor Dr. Evil was being unreasonable; they were both simply unaware of the ``inflation'' of needed resources required for serious fuzzing or blackmail of the world.

The first suggestion for escaping coverage, therefore was very simple:  run the fuzzer longer!  The Chaincode team immediately tried increasing their configuration to 5 million iterations (multiplying the number of executions, and runtime, by a factor of 50.  Based on initial success with a few targets, this was done for all targets, and eventually became the new default.  To a large extent, saturation was  no longer a problem.  This exploration of simply increasinig the fuzzing budget came early, about 15 days after the initial contact.  The Chaincode team also added new seeds by, as advised, running more fuzzers, including AFL and Honggfuzz, in the same time frame.

By May 20th, Bitcoin Core was also in OSS-Fuzz (it was not at the time of the first discussions, due to reporting requirements, but negotiations settled this problem): \url{https://github.com/google/oss-fuzz/tree/master/projects/bitcoin-core}.  From then on, Bitcoin Core has essentially been continuously fuzzed, and OSS-Fuzz quickly produced new crashes to investigate, and continues to do so:  \url{https://bugs.chromium.org/p/oss-fuzz/issues/list?q=bitcoin}.