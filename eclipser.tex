\section{Adding Fuzzer Diversity: Using Eclipser and Trying Ensemble Fuzzing}

The most obvious solution when fuzzer A faces saturation on a target codebase is to bring in fuzzer B.  In fact, the original blog post that attracted Chaincode's attention mentions this in the very definition of saturation:  ``Subsequently, a different fuzzer, applied to the same system, finds a lot of bugs.''  Of course, this is the easy case, and there can also be saturation across the meta-fuzzer defined as a composition of all fuzzers applied!  Still, ``throw in another fuzzer'' is almost always a good idea when performing serious fuzzing campaigns.  If that fuzzer adds some elements that are not present in any of the previously applied fuzzers, so much the bettter.

\subsection{Fuzzing with Eclipser}

\begin{sloppypar}
Eclipser~\cite{eclipser} is a fuzzer that combines AFL-like\footnote{In fact, the latest version of Eclipser simply uses AFL for non concolic fuzzing.} coverage-driven mutation-based fuzzing with a scalable form of grey-box concolic testing.  AFL++~\cite{AFLplusplus-Woot20} and libFuzzer \url{https://llvm.org/docs/LibFuzzer.html}, the two fuzzers most aggressively applied to the Bitcoin Core code, do not perform any kind of symbolic or concolic testing.  Eclipser is fairly easy to apply to new systems, since it uses QEMU to run on an ordinary binary, so the first order of business was to see if it could find new bugs or at least cover code AFL++ and libFuzzer were not able to reach.

Either directly (from runs using Eclipser itself) or indirectly (performing long AFL or libFuzzer runs seeded with Eclipser-generated tests), Eclipser produced thousands of new corpus seed files that were accepted as PRs to merge into the Bitcoin Core QA assets repo \url{https://github.com/bitcoin-core/qa-assets}.  The first author is now the third-largest contributor to the QA assets repo, in fact.  These files added hundreds of new coverage edges to the basis for OSS-Fuzz and other testing of Bitcoin Core.

On the other hand, these files added \emph{no} new covered statements; the additions were all edges, not exploration of completely un-covered code, the most promising form of new coverage~\cite{covdev,testedness}.  Nor did these tests expose any new bugs.  Of course, in the long run testing in OSS-Fuzz or on the QA team's servers may use these tests to help cover new code or find new bugs, but the immediate impact is more modest.

  One of the outcomes of the 80 hour effort was full documentation of how to run Eclipser v1.x on the Bitcoin Core code:  \url{https://github.com/bitcoin/bitcoin/blob/master/doc/fuzzing.md#fuzzing-bitcoin-core-using-eclipser-v1x}.
\end{sloppypar}

\subsection{Ensemble Fuzzing}

Given that Eclipser, while useful, did not produce dramatic results, simply running and adding instructions for more fuzzers did not seem like a particularly productive use of much more of the two-week effort.  However, because Eclipser was somewhat useful, one obvious way to exploit multiple fuzzers was to try \emph{ensemble fuzzing}.

Ensemble fuzzing~\cite{chen2019enfuzz} is an approach that recognizes the need for
diverse methods for test generation, at least in the context of
fuzzing; using multiple fuzzers to seed each other and avoid saturation is a core motivation for ensemble fuzzing.   Inspired by ensemble methods in machine learning~\cite{dietterich2002ensemble},
ensemble fuzzing runs multiple fuzzers, and uses inputs generated by
each fuzzer to seed the other fuzzers.  Ensemble fuzzing is currently (in principle)
supported by the Enfuzz website  (\url{http://wingtecher.com/Enfuzz})
and by the DeepState~\cite{goodman2018deepstate} front-end\footnote{See
  \url{https://blog.trailofbits.com/2019/09/03/deepstate-now-supports-ensemble-fuzzing/}.}.

However, the EnFuzz website has never, since the Bitcoin Core effort began, actually been up and working, and various build and library version errors made it impossible to get the GitHub version (\url{https://github.com/enfuzz/enfuzz}) to work, either.  DeepState's ensemble code is more limited, but works.  However, it would require re-writing Bitcoin Core test harnesses to use DeepState's GoogleTest-like API.  In theory, this is not a huge burden: the custom fuzzing core API built by the Bitcoin Core team is fairly similar, in concept, to DeepState, providing ways to obtain values of various types using different fuzzer back-ends.  However, there are numerous small differences and specialized behaviors in the Bitcoin code that would require substantial work to re-engineer, and DeepState would add a significant build dependency to the Bitcoin testing infrastructure; such a change might well not make it through the Bitcoin Core approval process, once done.   Further, the effort to re-write more than 100 targets would be substantial, even if most targets were fairly trivial to translate. Building a one-off verson not intended to be rolled into the main codebase might be worthwhile, but would clearly take more than the 80 hours available, for unknown payoff.   Therefore performing ensemble fuzzing of Bitcoin Core remains future work for the QA team, or awaits the arrival of more reliable ensemble fuzzers that operate through a libFuzzer, AFL, or Honggfuzz interface that requires no changes on the Bitcoin Core side.